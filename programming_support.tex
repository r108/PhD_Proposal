\subsection{WSN programming}
Today's WSN platforms have greatly benefited from the advances in manufacturing technologies.  Sensor nodes are becoming smaller, cheaper, more efficient and capable in terms of their processing power. Despite the substantial improvements in hardware there are still significant limitations associated with WSN application development. The literature has identified a significant gap \cite{Fok:2009:AMA:1552297.1552299,Levis:2002:MTV:635506.605407,Costa:2007:VMA:1304610.1306527,1621014} which exists between the complexity of the required applications and the lack of sufficient hardware abstractions that would simplify the programming and management of heterogeneous sensor nodes. 

Typically, the Operating System (OS) has the central role of providing Application Programming Interfaces (API) for user applications to the underlying hardware resources \cite{hailperin2007operating,Stallings:1998:OSI:272982}. Memory and CPU management, low-level resource abstraction and task scheduling for multitasking are some of the main responsibilities of a typical OS. Over the years, important developments have been made to provide light-weight operating systems for WSNs that meet the requirements of diverse and demanding user applications. \cite{1367266,1630599,bhatti2005mantis,eswaran2005nano,s110605900}.
Due to the unique characteristics of the motes, OS design approaches for WSNs greatly differ from traditional Operating Systems, hence the realization of the basic OS services is a non-trivial problem. A classification framework, which analyses the different approaches that are used for WSN OS design, is presented in \cite{Reddy:2009:WSN:1593545.1593549}. The survey classifies WSN OSs based on their architecture, execution model, reprogramming ability, scheduling and power management. 

In today's WSN deployments application programming involves working close to the OS and solving low-level system problems that requires technical knowledge which is rarely found amongst application programmers. Hence, the need for suitable high-level programming interfaces is apparent and was identified by \cite{mottola2011programming}. The work classifies the various programming approaches that have gained popularity in WSNs, provides a comprehensive comparison amongst the different schemes and highlights the most important design concerns to programming WSN nodes. 

Traditionally, WSN application developers create programs that are executed on top of a WSN OS such as Contiki \cite{1367266} or TinyOS \cite{1630599}, hence exploiting the OS' features (e.g. hardware abstractions, multi-threading, etc). This approach, however, infers that the application has to be bound with the OS into a single firmware image and uploaded to the nodes manually and imposes additional limitations that are related to the particular OS' architecture design (Event driven, Multi-threaded, etc.).

Simplifying application development is arguably the main advantage of accessing hardware resources via high level APIs. In WSNs these are normally provided in a number of different ways. Most commonly an operating system is used to hide operational complexities from user application logic.Apart from OSs, however, other approaches such as virtualisation with the use of Virtual Machines (VM) \cite{Levis:2002:MTV:635506.605407,simon2005squawk,hong2009tinyvm,4300022} and other middleware \cite{Fok:2009:AMA:1552297.1552299,1621014,6529470,6671886} have been widely proposed.

