\subsection{WSN programming}
Today's WSN platforms have greatly benefited from the advances in manufacturing technologies.  Sensor nodes are becoming smaller, cheaper, more efficient and capable in terms of their processing power. Despite the substantial improvements in hardware there are still significant limitations associated with WSN application development. The literature has identified a significant gap \cite{Fok:2009:AMA:1552297.1552299,Levis:2002:MTV:635506.605407,Costa:2007:VMA:1304610.1306527,1621014} which exists between the complexity of the required applications and the lack of sufficient hardware abstractions that would simplify the programming and management of heterogeneous sensor nodes. 

Typically, the Operating System (OS) has the central role of providing Application Programming Interfaces (API) for user applications to the underlying hardware resources \cite{hailperin2007operating,Stallings:1998:OSI:272982}. Memory and CPU management, low-level resource abstraction and task scheduling for multitasking are some of the main responsibilities of a typical OS. 
Due to the unique characteristics of the motes, OS design approaches for WSNs greatly differ from traditional OSs. 

Over the years, important developments have been made to provide light-weight operating systems for WSNs that meet the requirements of diverse and demanding user applications. \cite{1367266,1630599,bhatti2005mantis,eswaran2005nano,s110605900}.A classification framework, which analyses the different approaches that are used for WSN OS design, is presented in \cite{Reddy:2009:WSN:1593545.1593549}. The survey classifies WSN OSs based on their architecture, execution model, reprogramming ability, scheduling and power management. In today's WSN deployments application programming involves working close to the OS and solving low-level system problems that requires technical knowledge which is rarely found amongst application programmers. Hence, the need for suitable high-level programming interfaces is apparent and was identified by \cite{mottola2011programming}. The work classifies the various programming approaches that have gained popularity in WSNs, provides a comprehensive comparison amongst the different schemes and highlights the most important design concerns to program WSN nodes. 

The survey in \cite{mottola2011programming} outlines that the traditional WSNs programming practice is to  create programs that are executed on top of a WSN OS such as Contiki \cite{1367266} or TinyOS \cite{1630599}, hence exploiting the OS' features (e.g. hardware abstractions, multi-threading, etc). This approach, however, infers that the application has to be bound with the OS into a single firmware image and uploaded to the nodes manually and imposes additional limitations that are related to the particular OS' architecture design (Event driven, Multi-threaded, etc.).

Simplifying application development is arguably the main advantage of accessing hardware resources via high level APIs. In WSNs these are normally provided in a number of different ways. Most commonly an OS is used to hide operational complexities from user application logic. Apart from OSs, however, other approaches such as virtualisation with the use of Virtual Machines (VM) \cite{Levis:2002:MTV:635506.605407,simon2005squawk,hong2009tinyvm,4300022} and other middleware \cite{Fok:2009:AMA:1552297.1552299,1621014,6529470,6671886} have been widely proposed.

