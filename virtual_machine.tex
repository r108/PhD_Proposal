\subsection{Virtual machines (VMs)}
The benefits offered by a VM execution environment include application portability, multi application support and improved hardware utilization. On one hand, applications running in a VM tend to be slower than their native counterparts due to the overhead associated with byte code interpretation. On the other hand, in many cases the overhead is minimal. Nonetheless, benefits of VMs as flexible computational platforms are well known in mainstream computing\cite{Montero2011750} and in WSN domains alike \cite{Brouwers:2009:DFV:1644038.1644056}.  

Existing VM approaches for WSNs can greatly vary in how they are implemented. For example Squawk \cite{simon2005squawk}, which is a micro edition Java Virtual Machine (JVM) is implemented on the bare metal, while Maté \cite{Levis:2002:MTV:635506.605407}, a stack based byte code interpreter is implemented as a single component of TinyOS \cite{1630599} (an operating system for WSN nodes).

Squawk's core, unlike most VMs, was mainly written in Java that makes it easily portable but currently it is only available for the SunSPOT platform. It implements an application isolation mechanism to allow multiple application instances running concurrently and provides a high level API that enable developers to write wireless applications for WSN in Java.
 
Maté, on the other hand, runs as a single component of TinyOS.  It specifies 24 very compact -one byte long- instructions, 8 of which can be customized for a particular application. In order to reprogram existing WSN deployments, Maté introduces program updates via self-propagating code capsules that are transmitted over the whole network. More complex programs can easily be composed of multiple packets. 
This research work was one of the first successful attempts to implement a VM on a highly resource constrained WSN node. The developers of Maté identified the need for re-tasking as environmental conditions change and borrowed ideas from Active Networks (AN) architecture in which the execution codes are transmitted via active packets. Concurrency at instruction granularity is achieved through three interleaving execution contexts.  Data communication amongst contexts is made possible by a shared variable, a one word heap. Application code running in the VM can be multiplexed with other system tasks, however Maté does not explicitly support multiple concurrent application instances.

The original Maté research was further extended into a framework that enables application developers to generate tailored application specific virtual machines (ASVM) \cite{levis2004bridging} for WSNs. The VMs created by this framework also included an improved code propagation module which was based on the Trickle algorithm \cite{Levis:2004:TSA:1251175.1251177}. 

In addition to the ASVM generator other VM generators were developed over the years. One of which was the VMSTAR framework \cite{koshy2005vmstar} that allows programmers to generate VMs for sensor networks. Apart from the particular application, it also uses hardware specific details as its foundation to optimize its interpreter to the target platform. Extending application functionality is supported in VMSTAR through incremental linking.

Another VM generator is presented in \cite{Palmer:2004:VMG:1267242.1267243}. The research proposes a framework to create customized stack based VMs based on the hardware capabilities of the devices. For resource constrained sensor nodes only a scaled down version is implemented and the full VM for the more powerful ones where the different versions are fully compatible. This approach aims to assist interoperability amongst heterogeneous devices while exploiting the available performance of the devices with regards to their capabilities.  

The research behind Maté was a pioneering work that inspired other researchers and provided a foundation for several VM implementations. The most notable ones include DAViM \cite{Michiels:2006:DDA:1176866.1176868}  and Melete \cite{Yu:2006:SCA:1182807.1182822}.
 
DAViM allows the network to be reprogrammed dynamically by injecting application specific code, and provides isolated execution environments for several running applications.  

Melete adopted Maté's TinyScript, a relatively high level programming language, but also introduced a number of modifications to the original Maté VM. These included enhanced code propagation and application deployment mechanisms and most importantly support for concurrent applications.

Another unique VM approach, MagnetOS, is presented in \cite{Barr:2002:NSS:509526.509528}. It is a distributed OS, implemented as a single system image of a unified Java virtual machine that is installed across the sensor network nodes.

A number of other Java based VMs have also been proposed. TinyVM \cite{hong2009tinyvm} for example -runs atop TinyOS- is a byte code interpreter that implements a subset of the full JVM. Other implementations include Darjeeling \cite{Brouwers:2009:DFV:1644038.1644056}  and TakaTuka \cite{Aslam:2008:ITJ:1460412.1460472}.  

TakaTuka supports all but two of the Java byte-code instructions, threading, synchronized method calls and is fully compliant with the CLDC library \cite{debbabi2006security}, while Darjeeling prioritizes efficiency over functionality and does not provide support for floating point calculations, class reflection or synchronized method calls. 
Application development using Java is a very attractive option due to its wide portability and simplicity to program in a high level object oriented language.

The authors in \cite{895380} describe Scylla, a VM architecture for embedded systems, which differs in its execution model from all of the previously discussed VM implementations. Scylla VMs use a register based execution model as opposed to the stack based model that is used by most embedded VM implementations. Additionally, unlike most VMs Scylla does not interpret byte code, instead Scylla implements an on-the-fly compiler. Hence compiling byte code to native architectures only requires the re-encoding of the instruction words as they can be directly mapped. Furthermore, the register based execution model does not have the overhead associated with the additional PUSH and POP stack operations and also provide optimization by caching the results of previous calculations allowing faster execution of the instructions. On the other hand, stack based execution models can produce more compact codes because long operand addresses do not need to be explicitly specified instead short stack pointers are used. This property makes stack based VMs more attractive for WSNs due to their lower memory requirement and more efficient dissemination of compact byte code. 